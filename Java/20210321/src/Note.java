public class Note {
//    1.非递归前序遍历：
//    1）创建一个栈
//    2）把根节点入栈
//    3）取出栈顶元素，访问这个节点（打印）
//    4）把当前节点的右子树入栈，左子树入栈（非空）
//    5）回到3重复

//    2.非递归中序遍历：
//    1）创建一个栈
//    2）创建一个引用cur，从 root 开始一直向左，遇到非空节点入栈，当遇到空时，循环结束
//    3）取出栈顶元素，并访问（即最左侧元素）
//    4）让cur指向该节点的右子树，回到2继续执行
//    (遇空-出栈-访问右节点)

//    3.非递归后序遍历：
//    1）创建一个栈
//    2）创建一个 cur 引用， 从 root 出发，一直向左，遇到非空节点入栈，遇到空节点循环结束
//    3）栈顶元素不能立刻访问（需要判定，如果栈顶元素的右子树为空，则可以访问出栈；如果栈顶元素的右子树已经访问过，则也可以访问出栈；
//                        否则，不能立刻进行访问出栈）不能立即被访问，则 cur 指向栈顶的右子树，重复执行2
//
//    后序遍历的性质：
//    后序遍历的结果 = 左子树的后序 + 右子树的后序 + 根节点

//    堆和优先级队列：

//    大部分情况下，使用 Comparable 就可以，但有时必须用 Comparator
//    1）如果这个类有多种比较规则的时候
//    2）如果这个类是别人写的类，自己无法更改

//    优先级队列应用：
//    1）排序——（堆排序）
//    2）topk问题——（给定一亿个数字，找到其中前一千个较大的数字）

//    堆：
//    1.堆是一种完全二叉树
//    2.堆中某个结点的值总是不大于其父节点或者不小于其父节点（大堆/小堆）

//    堆的基本操作：
//    1）插入元素
//    2）获取堆顶元素
//    3）删除堆顶元素

//    向下调整前提：
//    当前节点的左右字数，都是符合堆的要求，只有根节点不符合，这个时候就可以针对根节点开始进行向下调整

//    以大堆为例：
//    1.先找到左右字数中的较大的值
//    2.将较大的值和根节点进行比较，判定是否符堆的要求，如果不符合，就交换这两个元素
//    3.交换完毕之后，再针对对应的子树继续进行向下调整，知道整个数都符合堆的规则为止

//    排序：
//

}
