package Note;

public class Note {
//    一个对象初始化顺序：
//    1.默认值
//    2.就地初始化   代码块（谁在前谁先执行）
//    3.构造方法

//    多态
//    1.向上转型： 父类引用指向子类的实例（子类的引用转成了父类的引用）
//      a) 直接赋值  b) 方法传参  c) 方法返回
//    2.动态绑定： 父类和子类之间都具有同名并且同参数的方法，这时候通过父类引用调用该方法的时候，就是在运行时决定调用父类版本还是子类版本
//    3.方法重写：

//    多态：一个引用能表现出多种不同的形态
//      a) 多态是封装的更进异步，让类的使用者不需要关注具体对象的类型，也能正确使用
//      b) 方便扩展，未来如果需要新增新的子类，对于类的使用者来说影响很小
//      c) 消灭一些分支语句，降低程序的圈复杂度

//    在java体系中 必须搭配继承才能使用多态
//    如果抛开java来看，有些其他编程语言体现多态时候，不需要依托继承，或者不需要依托向上转型，动态绑定，方法重写

//    c++ 的多态有两种形式
//    动态的多态 和java差不多，使用virtual的关键字
//    静态的多态

//    经典面试题：  解释多态

//    向下转型 其实就相当于 向上转型的逆过程 通过向上转型得到的父类的引用 可以借助向下转型还远到原来的类型
//     应用场景：有些方法知识在子类中存在，但在父类中不存在 此时使用多态的方法就无法执行到对应的子类的方法
//              就必须吧父类的引用先转回成子类的引用，然后再调用对应的方法，即 向下转型
//     可以在向下转型之前先做出判定 判定当前的父类的引用是不是指向该子类  （instanceof来判断）

//    对象之间比较的三种方法：
//    1. 比较值 例如：String.equals
//    2. 比较身份  ==
//    3. 比较类型  instanceof
//        如果想比较两个 StringBuilder 的内容，可先把 StringBuilder 生成 toString

//    抽象类 不能进行实例化
//    抽象化 不能是private

}
