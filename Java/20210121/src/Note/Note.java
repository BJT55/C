package Note;

public class Note {
//   XYZ题：
//   创建子类实例的时候，先构造父类的实例（调用父类的构造方法）
//   初始化顺序： 先执行就地初始化，再执行代码块，然后执行构造方法
//   1. new Z() 的时候，回西安构造父类的实例 进入X中执行
//   2. 构造 X 的实例时候 先就地初始化 再调用构造方法 于是进入 Y 执行
//   3. 执行 Y 的构造方法 打印 Y
//   4. 执行 X 的构造方法 打印 X
//   5. 父类 X 以及准备就绪 开始进行子类 Z 的初始化
//   6. 对于 Z 来说也是先执行就地初始化 在调用构造方法
//   7. 就地初始化 就是进入 Y 执行 只需要调用构造方法即可 打印Y
//   8. 执行 Z 自身的构造方法 打印 Z

//   static 修饰的代码块执行始终执行在普通代码块之前
//   static 代码块是在类加载的时候执行的
//   普通代码块是在创建实例的时候执行的
//   类加载始终是在创建实例之前
//   若有两个static 先执行上面的static

//    对象初始化：默认初始化、就地初始化、代码块初始化、构造方法初始化
//    创建成员变量的过程中 立刻进行初始化

//    多态： 能够帮我们解决大量分支语句的情况
//    1. 向上转型： 父类的引用指向了一个子类的对象
//    2. 动态绑定： 如果父类中包含的方法在子类中有对应的同名同参数的方法，就会进行动态绑定
//       静态/动态  分别指： 编译七 / 运行时   和static没有任何关系
//       即运行时要调用哪个方法
//    3. 方法重写：子类实现父类同名方法 并且参数的类型和个数完全相同
//        重载：是同一个作用域中，方法名相同，参数不同（类型/个数）
//        重写：是父类和子类之间，存在同名方法，参数相同，此时通过父类引用调用该方法，就能触发重写
//
//    多态直观理解，“一个引用，对应到多重形态（不同类型的实例）”
//    多态的设计思想本质上是封装
//    多态的第一个好处：
//    多态的第二个好处：方便扩展
//    多态的第三个好处：减少一些分支语句（如果不适用多态，实现同样的逻辑，就会比较复杂）

//    对象（实例） 里面包含两个部分： 属性（成员变量） 和 方法（成员函数）

//    注解： 父类和子类有同名同参数方法，添加注解，显式的告诉编译器，当前这个子类的方法是重写了父类的方法
//          如果没有注解，代码也可以运行，添加注解后，编译器能给我们检查和校验工作
//          @Override 只是注解之一  java中注解还有很多 也可以自己创建
}
