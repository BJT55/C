package Note;

public class Note {
//    多态：一个引用能够表现出多种形态
//    a) 封装的更进一步，燃事故迎着不必关注实际的类型，就能使用类
//    b) 降低代码的复杂程度，消除一些分支语句
//    c) 扩展能力更强
//    类型转换异常 使用关键字instanceof来进行判断

//    接口相当于是一种约束，要求了实现该接口的类，必须重写所有的接口中的抽象方法

//    一个类可以实现多个接口，每个接口中可以有多个抽象方法
//    多个接口之间用 " , " 进行分割

//    异常
//    异常是在程序运行过程中出现的一种错误（编译期、运行时）
//    异常是一种帮助我们解决问题的很好手段：异常种类很多，分别代表不同的含义，一旦出现某种异常情况，此时这个异常时明确的，可以明确地告诉我们异常的原因

//    防御式编程：两种体现形式
//    1.LBYL： look before you leap 操作之前做好充分的检查，检查完上一步后，再来做下一步操作，如果上一步失败，就不继续执行
//    2.EAFP： it is easier to ask forgiveness than permission 时候获取原谅比事前获取可更简单、先斩后奏

//    异常的具体语法：
//    1.try ： try 语句块中防止可能会抛出异常的代码
//    2.catch ： catch 语句块中防止用来处理异常的代码 try 和 catch 往往要搭配使用
//    3.throw ： 主动抛出一个异常对象（java 的异常本质上就是一个一个的对象）
//    4.throws ： 某个方法可能会跑出某些异常
//    5.finally ： 一般用于异常处理完毕后的收尾

//    try 和 catch 的执行顺序：
//    1. 先执行 try 中的代码（按顺序执行）
//    2. 执行 try 代码的过程中，如果出现异常，就会进入到 catch 执行， try 中剩余的代码就不再执行
//    3. 当 catch 也执行完毕后，就会继续执行异常抛出后的代码，程序没有异常终止

//    如果 try 中抛出的异常的类型和 catch 中声明的类型不匹配，此时 catch 中的代码不会被执行到
//    即使用 try 和 catch 的时候，必须明确知道抛出异常的类型
//    如果 try 中可能抛出多种异常的话，就需要多个 catch 语句来进行处理（即 一对多）
//    多个 catch 之间就类似多分支语句一样
//      也可以使用一个 catch 来捕获多个异常（假设两种异常的处理逻辑是一样的，使用 “ | ”逻辑或来并行多个异常的类型）
//      或者直接使用 Exception （这是一个级别很高的父类）
//      在进行 catch 的类型的匹配的时候，不一定要求类型完全一模一样，如果抛出的异常时 catch 的参数的异常的之类也是可以的，这个操作本质上是 向上转型

//    try catch 在用时会涉及到代码的跳转，可以使用 finally 放到他们的后面
//    此时 finally 中的逻辑是保证一定会执行到的，这个里面一般是用来放一些“收尾”/"善后"工作的
//    收尾工作：
//       例如  文件操作——需要打开文件，再使用，用完后要关闭，即关闭文件的操作可以放到finally中
//       多线程代码中设计到的 加锁： 加锁之后要解锁，如果由于抛出异常没有执行到解锁操作，就有可能导致死锁的问题，即可以吧解锁的操作放到finally中
//    使用 finally 回收资源代码写起来比较麻烦，还可以使用 java1.7 中的

//    如果当前方法中没有合适的 catch，异常就会沿着调用栈，向上传递
//    如果异常网上传递的过程中，一直到了最上面之后也没有 catch，此时就相当于没有合适的代码来 catch 异常，此时异常就会由 JVM 自己来处理，即直接打印异常调用栈，并且程序直接终止

}