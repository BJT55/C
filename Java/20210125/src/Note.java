import Test.MyArray2;

public class Note {
//    面向对象：
//    1.类和对象
//    2.封装
//    3.继承
//    4.多态
//    5.抽象类
//    6.接口

//    异常：
//    背景：防御式编程
//    LBYL：先判断检查在进行操作
//    EAFP：先执行再判断检查

//    throw : 主动抛出异常（被抛出的异常其实是一个对象）
//    throws : 标注当前的方法，可能抛出什么样的异常

//    java 的异常体系：
//    描述 java 标准库中提供的异常类都有哪些，并且分成哪几个类
//    Error 是系统级别的异常，JVM 内部使用的，普通程序员不应该使用 Error 这个体系
//    Exception 是应用级别的异常，普通程序员应该要使用这一组系列

//    受查异常：如果程序中某个方法抛出了这个异常，就必须对这个异常进行显式的处理（1.直接try catch 2.使用 throws 声明可能会跑出这个异常）
//    非受查异常：可以不显式处理
//    Error 是受非查异常，此时此种情况一定非常严重
//    RuntimeException 也是非受查异常，最常见异常，影响不是很大
//    剩余都是受查异常

//    泛型：让一个类/一个方法，能够支持多种不同的数据类型
//    为什么要使用泛型？
//    如果没有泛型机制，当前封装的数组类，只能针对 int 进行存储
//    如果需要针对 String，就需要在创建一个类，吧里面涉及到的 int 的类型改成 String，后续如果需要增加其他类型，都得如此操作
//    有了泛型之后，就可以让一套代码服务多种类型
//    如果把类中的持有数组弄成 Object[] 也可以实现多种类型，但需要大量的类型转换

//    使用 Object 来凑合完成 泛型 效果，是比较麻烦的
//    1.需要写一些类型转换代码
//    2.类型转换的代码容易出错，缺少一些必要的类型检查
//    （这样的做法类似 C 中使用 void* 来凑合完成 泛型 ）

//    使用泛型之后，在针对对象实例化的时候需要填写泛型参数的实际类型
//     MyArray2<String> myArray2 =  new MyArray2<>();
//    把这个实际的类型填写进去之后，实际的泛型参数就都被自动的替换成String

//    泛型这个实际生活中很少用，面试中也不会考到，目的是为了更好的理解集合类
//    java 的泛型只能是内置类型，就需要使用对应的包装类（包装类也是引用类）
//    注意： java 的泛型，本质上还是基于 Object 机制来实现的
//    泛型存在的意义，就是帮助我们完成了 类型校验 和 类型转换
//    如果是 C++ 的泛型，和 java 是两套机制， C++ 的泛型允许是内置类型，因为其泛型本质上是在编译期生成一套全新的机制

//    类型边界
//    定义泛型类的时候，对未来实例化的时候能传入的类型参数做出限制
//    泛型参数这里的类型不应该随便填，而要根据时间情况做出一些约束和校验

//    public class MyArray2<E extends Animal>  当前 的类型参数必须设成 Animal 或者 Animal 的子类

//    通配符：
//    限制泛型参数传入的条件 是在泛型类的使用的时候涉及到的 尤其是泛型类作为某个方法的参数的时候
//    次数讨论的类型边界 + 通配符（通配符的上界下界） 都是“锦上添花”，为了更充分的发挥泛型在编译器的检查效果，如果不加这些检查，代码仍然能够照常写，没有什么问题

//    泛型中的父子类型（举例：这个教室的另一个教室的父亲）
//    如果能够完成向上转型，就可以承认“父子关系”

//    类型擦除：描述的是 java 泛型的底层实现原理
//       结论：泛型是一个语法糖而言，本质上在底层是使用 OBject 完成的
//            编译器在编译过程中会自动记录泛型参数的实际类型，并且帮助我们完成一些类型转换和类型校验工作，一旦代码编译完成，到了字节码中，此时就不再涉及到任何和泛型相关的信息了


}
