package Note;

public class Test {
    // 面向对象编程

    // 继承：
    // 目的：代码重用、类的重用
    // 概念：父类/基类/超类  子类/派生类（继承父类的类）
    // 关键字： extends（扩展）
    // 继承就是为了代码重用，为了把多个类之间的共同的代码提取出来，放到”父类“中

    // java是“单继承”，java中不支持多继承
    // 一个类只能有一个父类，但这个父类还可以继承其他的类

    // 使用 super 关键字就能够获得父类的实例的引用

    // 每个类都有构造方法，如果不显式的创建构造方法，那么编译器就会默认生成一个构造方法
    // 当父类里面没有写构造方法的时候，就被自动生成了没有参数版本的构造方法
    // 此时如果直接new 子类实例，就会调用到刚才父类这个没有参数版本的构造方法
    // 当父类例有构造方法的时候，并且这个构造方法带有参数的时候，编译器就不在自动生成五参数版本的构造方法
    // 此时在创建子类实例，就需要显式的调用父类的构造方法，并且进行传参，否则创建不出来父类的实例，就会编译出错
    // 修改这个问题的办法： 只要在子类的构造方法中显式调用父类的构造方法即可（使用super）

    // 结论：构造子类实例的时候，会在子类实例的内部自动构造一个父类的实例（子类实例中包含了父类实例，父类实例包含了父类的属性）
    // 如果父类中有多重构造方法，这时候构造子类就需要显式的决定哪个构造方法
    // 另一方面，如果父类只有一个没有参数版本的构造方法，此时子类可以省略父类的构造方法的调用
    // 在另一方面，如果父类没有显式的定义任何构造方法，此时相当于编译器自动给父类输出了没有参数的构造方法，子类仍然不需要显式调用

    // 显示：必须明确写出来
    // 隐式：不写出来也可以

    // 创建子类实例时，先调用父类的构造方法，在调用子类的构造方法
    // 强制要求： 如果是显示调用父类的构造方法，必须把父类的构造方法放到第一行代码去执行，不能放到下面

    // public： 可以在类外访问
    // private： 只能在类内部访问
    // default（啥都不写，默认）：包级权限，可以被同包的其他类访问
    // protected： 可以被子类访问，也可以同包的其他类访问（在被同包的类访问的基础上，还能被其他包的子类访问）

    // 可以用 static 来修饰一个内部类，表示这是静态内部类 和继承没有关系
    // 类前的 public 和继承也没有关系，表示这个类可以别其他包使用，不加表示这个类只能在包内使用

    // 使用 final 显式的禁止继承，防止继承被滥用
    // 继承 关键是 代码重用 子类会拥有父类的属性和方法

    // 组合（一个类的成员也可以是）： 代码重用 ，也是面向对象的一个重要特性
    // 组合表示的语义  has - a （拥有xxx ,包含 xxx）
    // 继承表示的语义 is - a （ 是xxx ）
    //
    //
    //
    //
}
