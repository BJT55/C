package test01;

public class test01 {
    //方法区：存的是一个一个的“类相关的信息”（每个类的方法的二进制的指令也是在这里）
    //对于属性来说，如果属性是一个实例属性，那么不在方法区，而是跟着实例走（实例一般在堆上）
    //对于方法来说，不管是加static还是不加，对应的内容都是在方法中
    //如果属性是一个类属性(static)，那么也就在方法区中

    //String是引用类型
    //内置类型：有且只有8种  (byte short int long float double char boolean)
    //引用类型：除了上面的8种其他都是 (数组 String 类)

    //栈不是只有一个，每个线程都有自己的栈
    //堆和方法区，每个JVM都是只有一份的




    // 认识String类：

    //java中的字符串String 和字符串数组char[] 之间没有关联关系！！和\0也没有任何关系
    //String 在java.lang这个包中 ：java.lang是最基础，最常用的一个包，不需要额外导入
    //java的字符串常量会被保存到“字符串常量池”中，此时字符串常量
    //如果想要比较俩个字符串的内容，则需要使用.equals 方法
    // .equals 依次遍历字符串中的每个字符，只要有一个字符不一样，就返回false

    //池：
    //内存池、线程池、进程池、数据库连接池、对象池
    //池的目的就是为了降低开销，提高效率
    //本质是把频繁使用的东西提前保存好，已备用到的时候，随时就能使用

    //调用intern方法，就会拿着当前这个组反映串中的内容在字符串常量池中找，看当前这个内容是否存在与池内
    //如果存在，则直接返回该池中的地址
    //如果不存在，则吧当前字符串中的内容佳佳到常量池中，返回池中的地址

    //常量池是JVM划分的一个内存区域，JVM一运行的时候，就会专门弄一个区域作为常量池（也就是堆的一个部分）
    //编译器在编译java代码的时候能够看到”hello“这个东西，能识别出这事一个字面值常量，于是就会自动把这个东西加入到常量池中
    //另一方面，调用intern的时候网易当这个字符串没有在常量池中，也会先把这个字符串加到常量池中

    //java的String是不可变对象
    // final修饰的是常量，final修饰的是一个引用类型的话，表示该引用的指向（引用中存的地址不能改）
    // 带static 是类属性/类方法  不带static 是实例属性/实例方法

    //光标放在所要查询的方法上，Ctrl+鼠标左键点击 进入该方法中

    //private无法在类的外部来访问，所以无法在类的外面直接通过[]的形式来获取或者修改该字符数组的内容
    //没有public 的方法能够修改这个 value 数组的内容

    //java 的 String 为什么要设计成不可变的？
    //1.方便放到池中，如果是可变的对象，一旦池中的内容发生改变，就会影响到所欲引用这个池对象的结果
    //2.对象内容不可变，则对象hashCode也不可变，方便和hash表这样的结构配合使用
    //                  hashCode：简单组包的理解成对象的“签名”，用来识别对象身份的方式
    //3.对象不可见，线程安全更有保障
    //java中为了方便修改提供了 StringBuilder 和 StringBuffer 这样的类来进行修改

    //C++ 的 std::string 就是可变对象
    //可变对象的好处：方便修改（修改起来比较高效）
    //C++为了高效的保存字符串，也有类似的“池”的机制
    //由于是可变对象，涉及到 “ 写时拷贝 ” 机制  真正修改时才拷贝

    //Linux中有一个fork这样的系统调用，用来创建进程，也涉及到写时拷贝机制

    //“反射”/自省  面向对象程序设计的一个重要特征
    // 反射 和 封装 是背道而驰的
    // 1. 使用反射往往可能打破封装
    // 2. 反射的代码比较复杂，容易出错
    // 3. 反射牺牲了编译器自身的一些检查校验机制，更需要程序员仍保证代码的正确性

    // C++ 的 const 和 java 的 final 的区别：
    // java 中的final：
    // 1.final修饰一个变量，表示常量，如果修饰的是引用类型，表示引用的指向不能修改
    // 2.final修饰一个类，表示这个类不能被其他类所继承
    // C++ 中的 const：
    // 1.const 修饰一个变量，表示常量  const 修饰指针的话，既可以用来限制指针的指向不能修改，也能限制指针的指向对象内容不能修改
    // 2.const 修饰某个类的方法时（放到方法的后面），表示该方法的对应的this指向的是不可变对象
    // 3.让编译器更好的优化（编译期求值）

    // 字符 和 字符串 之间的转换

    // 字节 和 字符串 之间的转换
    //
    //
    //
    //
    //
    //
}
